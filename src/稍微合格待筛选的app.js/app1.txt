import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import GomokuGameABI from './GomokuGameABI.json'; // 引入合约ABI
import './App.css'; // 引入CSS文件

const contractAddress = '0x55F2b31996273A60F4433Eb02E76390ce56D2Ec9'; // 智能合约地址
const scrollChainId = '0x82750'; // Scroll主网 Chain ID

function App() {
  const [web3, setWeb3] = useState(null);
  const [account, setAccount] = useState(null);
  const [contract, setContract] = useState(null);
  const [game, setGame] = useState({
    board: Array(15).fill().map(() => Array(15).fill(0)), // 初始化15x15棋盘
    currentTurn: null,
    player1: null,
    player2: 'AI',
    player1Color: null, // 玩家颜色
    player2Color: null, // AI颜色
  });
  const [winner, setWinner] = useState(null); // 胜者状态

  // 初始化Web3
  useEffect(() => {
    if (window.ethereum) {
      setWeb3(new ethers.providers.Web3Provider(window.ethereum));
    } else {
      alert('请安装MetaMask！');
    }
  }, []);

  // 连接钱包并检查是否在Scroll主网
  const connectWallet = async () => {
    try {
      if (!web3) return;

      const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
      setAccount(accounts[0]);

      const chainId = await web3.getSigner().getChainId();
      if (chainId !== parseInt(scrollChainId, 16)) {
        try {
          // 尝试切换到 Scroll 主网
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: scrollChainId }],
          });
        } catch (switchError) {
          // 如果 Scroll 主网还没有添加到 MetaMask，提示用户添加
          if (switchError.code === 4902) {
            await window.ethereum.request({
              method: 'wallet_addEthereumChain',
              params: [
                {
                  chainId: scrollChainId,
                  chainName: 'Scroll',
                  rpcUrls: ['https://rpc.scroll.io'],
                  blockExplorerUrls: ['https://scrollscan.com'],
                  nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                },
              ],
            });
          } else {
            console.error('切换到 Scroll 主网失败', switchError);
          }
        }
      }

      const signer = web3.getSigner();
      const contractInstance = new ethers.Contract(contractAddress, GomokuGameABI, signer);
      setContract(contractInstance);
    } catch (error) {
      console.error('连接失败', error);
    }
  };

  // 随机选择谁先手
  const startGame = async () => {
    if (contract && account) {
      const randomStart = Math.random() < 0.5 ? 'AI' : account;
      const randomColor = Math.random() < 0.5 ? 'white' : 'black';

      setGame({
        ...game,
        currentTurn: randomStart,
        player1: account,
        player1Color: randomColor,
        player2Color: randomColor === 'white' ? 'black' : 'white',
      });

      if (randomStart === 'AI') {
        handleAIMove(); // 如果AI先手，则AI开始下棋
      }
    } else {
      console.log('请先连接钱包');
    }
  };

  // 玩家落子逻辑
  const handlePlayerMove = async (x, y) => {
    if (game.currentTurn === account && game.board[x][y] === 0) {
      const newBoard = [...game.board];
      newBoard[x][y] = game.player1Color === 'black' ? 1 : 2;

      setGame({ ...game, board: newBoard, currentTurn: 'AI' });

      if (checkWinner(newBoard, game.player1Color === 'black' ? 1 : 2)) {
        setWinner(account);
        alert('恭喜你，赢了！');
        await contract._mintNFT(winner); // NFT 发放逻辑
      } else {
        handleAIMove();
      }
    }
  };

  // AI 防守和进攻逻辑
  const handleAIMove = async () => {
    let newBoard = [...game.board];

    // 防守逻辑：优先阻挡玩家的三子连珠
    const blockMove = findBestMove(newBoard, game.player1Color === 'black' ? 1 : 2);
    if (blockMove) {
      newBoard[blockMove.x][blockMove.y] = game.player2Color === 'black' ? 1 : 2;
    } else {
      // 如果没有防守需求，AI 自己寻找最佳进攻点
      const bestMove = findBestMove(newBoard, game.player2Color === 'black' ? 1 : 2);
      if (bestMove) {
        newBoard[bestMove.x][bestMove.y] = game.player2Color === 'black' ? 1 : 2;
      } else {
        // 随机选择一个空格子
        let aiX = Math.floor(Math.random() * 15);
        let aiY = Math.floor(Math.random() * 15);
        while (newBoard[aiX][aiY] !== 0) {
          aiX = Math.floor(Math.random() * 15);
          aiY = Math.floor(Math.random() * 15);
        }
        newBoard[aiX][aiY] = game.player2Color === 'black' ? 1 : 2;
      }
    }

    if (checkWinner(newBoard, game.player2Color === 'black' ? 1 : 2)) {
      setWinner('AI');
      alert('AI 获胜！');
    } else {
      setGame({ ...game, board: newBoard, currentTurn: account });
    }
  };

  // 查找最佳落子点的逻辑（防守或进攻）
  const findBestMove = (board, player) => {
    const directions = [
      { x: 1, y: 0 }, // 横向
      { x: 0, y: 1 }, // 纵向
      { x: 1, y: 1 }, // 右下斜线
      { x: 1, y: -1 }, // 左下斜线
    ];

    let bestMove = null;
    let bestScore = 0;

    for (let x = 0; x < 15; x++) {
      for (let y = 0; y < 15; y++) {
        if (board[x][y] === 0) {
          // 检查这个点在不同方向上的得分（即：是否为三子连珠或防守关键点）
          let score = 0;

          for (const { x: dx, y: dy } of directions) {
            let count = 0;
            let i = 1;

            // 检查当前方向的连珠数
            while (x + dx * i < 15 && y + dy * i < 15 && board[x + dx * i][y + dy * i] === player) {
              count++;
              i++;
            }

            score = Math.max(score, count);
          }

          if (score >= 3 && score > bestScore) {
            bestScore = score;
            bestMove = { x, y };
          }
        }
      }
    }

    return bestMove;
  };

  // 检查胜利条件
  const checkWinner = (board, player) => {
    const directions = [
      { x: 1, y: 0 }, // 横向
      { x: 0, y: 1 }, // 纵向
      { x: 1, y: 1 }, // 右下斜线
      { x: 1, y: -1 }, // 左下斜线
    ];

    for (let x = 0; x < 15; x++) {
      for (let y = 0; y < 15; y++) {
        if (board[x][y] === player) {
          for (const { x: dx, y: dy } of directions) {
            let count = 1;
            let i = 1;
            while (x + dx * i < 15 && y + dy * i < 15 && board[x + dx * i][y + dy * i] === player) {
              count++;
              i++;
            }
            if (count >= 5) return true;
          }
        }
      }
    }
    return false;
  };

  return (
    <div className="App">
      <h1>Gomoku 五子棋</h1>
      <div className="wallet">
        <button onClick={connectWallet}>
          {account ? `已连接: ${account.slice(0, 6)}...${account.slice(-4)}` : '连接钱包'}
        </button>
        <button onClick={startGame}>开始游戏</button>
      </div>
      <div className="board">
        {game.board.map((row, rowIndex) =>
          row.map((cell, colIndex) => (
            <button
              key={`${rowIndex}-${colIndex}`}
              className="board-cell"
              onClick={() => handlePlayerMove(rowIndex, colIndex)}
            >
              {cell === 1 ? '⚫' : cell === 2 ? '⚪' : ''}
            </button>
          ))
        )}
      </div>
    </div>
  );
}

export default App;
