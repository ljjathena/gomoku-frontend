import React, { useState, useEffect, useCallback } from 'react';
import './App.css';

const BOARD_SIZE = 19;
const EMPTY = null;
const BLACK = 'B';
const WHITE = 'W';
const MAX_DEPTH = 3; // 根据需要调整递归深度

// 棋盘初始化
const initializeBoard = () => {
  return Array(BOARD_SIZE)
    .fill(null)
    .map(() => Array(BOARD_SIZE).fill(EMPTY));
};

// 评分表，定义各种棋型的评分
const SCORES = {
  FIVE: 100000,
  FOUR: 10000,
  THREE: 1000,
  TWO: 100,
  BLOCKED_FOUR: 1000,
  BLOCKED_THREE: 100,
  BLOCKED_TWO: 10,
};

// 检查特定方向上的棋型
const countStones = (board, x, y, dx, dy, player) => {
  let count = 0;
  let block = 0;
  let empty = 0;

  // 正向
  for (let i = 1; ; i++) {
    const nx = x + i * dx;
    const ny = y + i * dy;
    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
      block++;
      break;
    }
    const cell = board[nx][ny];
    if (cell === player) {
      count++;
    } else if (cell === EMPTY) {
      if (empty === 0 && nx + dx >= 0 && nx + dx < BOARD_SIZE && ny + dy >= 0 && ny + dy < BOARD_SIZE && board[nx + dx][ny + dy] === player) {
        empty = count + 1;
        continue;
      } else {
        break;
      }
    } else {
      block++;
      break;
    }
  }

  // 反向
  for (let i = 1; ; i++) {
    const nx = x - i * dx;
    const ny = y - i * dy;
    if (nx < 0 || nx >= BOARD_SIZE || ny < 0 || ny >= BOARD_SIZE) {
      block++;
      break;
    }
    const cell = board[nx][ny];
    if (cell === player) {
      count++;
    } else if (cell === EMPTY) {
      if (empty === 0 && nx - dx >= 0 && nx - dx < BOARD_SIZE && ny - dy >= 0 && ny - dy < BOARD_SIZE && board[nx - dx][ny - dy] === player) {
        empty = count + 1;
        continue;
      } else {
        break;
      }
    } else {
      block++;
      break;
    }
  }

  return { count, block, empty };
};

// 调整后的评分函数
const evaluatePoint = (board, x, y, player) => {
  let totalScore = 0;

  const directions = [
    [1, 0], // 横向
    [0, 1], // 纵向
    [1, 1], // 对角线 \
    [1, -1], // 对角线 /
  ];

  for (let [dx, dy] of directions) {
    const { count, block } = countStones(board, x, y, dx, dy, player);
    totalScore += getScore(count, block);
  }

  return totalScore;
};

// 根据连续的棋子数和封堵情况返回分数
const getScore = (count, block) => {
  if (count >= 5) return SCORES.FIVE;
  if (block === 0) {
    if (count === 4) return SCORES.FOUR;
    if (count === 3) return SCORES.THREE;
    if (count === 2) return SCORES.TWO;
  } else if (block === 1) {
    if (count === 4) return SCORES.BLOCKED_FOUR;
    if (count === 3) return SCORES.BLOCKED_THREE;
    if (count === 2) return SCORES.BLOCKED_TWO;
  }
  return 0;
};

let aiColor; // AI 颜色定义

// 使用 Minimax 算法结合 Alpha-Beta 剪枝
const getBestMove = (board, player, opponent, depth = MAX_DEPTH, alpha = -Infinity, beta = Infinity) => {
  if (depth === 0) {
    const score = evaluateBoard(board, aiColor, opponent);
    return [null, null, score];
  }

  const moves = generateMoves(board);

  let bestMove = null;
  let bestScore = player === aiColor ? -Infinity : Infinity;

  for (let [i, j] of moves) {
    board[i][j] = player;

    if (checkWin(i, j, player, board)) {
      board[i][j] = EMPTY;
      const score = player === aiColor ? Infinity : -Infinity;
      return [i, j, score];
    }

    const [_, __, score] = getBestMove(board, opponent, player, depth - 1, alpha, beta);
    board[i][j] = EMPTY;

    if (player === aiColor) {
      if (score > bestScore) {
        bestScore = score;
        bestMove = [i, j];
      }
      alpha = Math.max(alpha, bestScore);
    } else {
      if (score < bestScore) {
        bestScore = score;
        bestMove = [i, j];
      }
      beta = Math.min(beta, bestScore);
    }

    if (beta <= alpha) {
      break;
    }
  }

  return [...(bestMove || [0, 0]), bestScore];
};

// 评估整个棋盘的得分
const evaluateBoard = (board, player, opponent) => {
  let playerScore = 0;
  let opponentScore = 0;

  for (let i = 0; i < BOARD_SIZE; i++) {
    for (let j = 0; j < BOARD_SIZE; j++) {
      if (board[i][j] === player) {
        playerScore += evaluatePoint(board, i, j, player);
      } else if (board[i][j] === opponent) {
        opponentScore += evaluatePoint(board, i, j, opponent);
      }
    }
  }

  return playerScore - opponentScore;
};

// 生成可行的走法，只考虑已有棋子附近的空位
const generateMoves = (board) => {
  const moves = [];
  const visited = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(false));

  for (let i = 0; i < BOARD_SIZE; i++) {
    for (let j = 0; j < BOARD_SIZE; j++) {
      if (board[i][j] !== EMPTY) {
        for (let x = -2; x <= 2; x++) {
          for (let y = -2; y <= 2; y++) {
            const nx = i + x;
            const ny = j + y;
            if (nx >= 0 && nx < BOARD_SIZE && ny >= 0 && ny < BOARD_SIZE && board[nx][ny] === EMPTY && !visited[nx][ny]) {
              moves.push([nx, ny]);
              visited[nx][ny] = true;
            }
          }
        }
      }
    }
  }

  // 如果棋盘为空，返回中心点
  if (moves.length === 0) {
    const center = Math.floor(BOARD_SIZE / 2);
    moves.push([center, center]);
  }

  return moves;
};

// 检查是否胜利
const checkWin = (x, y, player, board) => {
  return (
    checkLine(x, y, 1, 0, player, board) || // 横向
    checkLine(x, y, 0, 1, player, board) || // 纵向
    checkLine(x, y, 1, 1, player, board) || // 对角线1
    checkLine(x, y, 1, -1, player, board) // 对角线2
  );
};

// 检查某一方向是否有五连珠
const checkLine = (x, y, dx, dy, player, board) => {
  let count = 1;

  for (let i = 1; i < 5; i++) {
    const newX = x + i * dx;
    const newY = y + i * dy;
    if (
      newX >= 0 &&
      newX < BOARD_SIZE &&
      newY >= 0 &&
      newY < BOARD_SIZE &&
      board[newX][newY] === player
    ) {
      count++;
    } else {
      break;
    }
  }

  for (let i = 1; i < 5; i++) {
    const newX = x - i * dx;
    const newY = y - i * dy;
    if (
      newX >= 0 &&
      newX < BOARD_SIZE &&
      newY >= 0 &&
      newY < BOARD_SIZE &&
      board[newX][newY] === player
    ) {
      count++;
    } else {
      break;
    }
  }

  return count >= 5;
};

const App = () => {
  const [board, setBoard] = useState(initializeBoard());
  const [playerColor, setPlayerColor] = useState(BLACK);
  const [winner, setWinner] = useState(null);
  const [isAiTurn, setIsAiTurn] = useState(false);

  useEffect(() => {
    const isPlayerBlack = Math.random() > 0.5;
    if (isPlayerBlack) {
      setPlayerColor(BLACK);
      aiColor = WHITE;
    } else {
      setPlayerColor(WHITE);
      aiColor = BLACK;
      setIsAiTurn(true); // AI 先手
    }
  }, []);

  // 玩家点击棋盘落子
  const handleBoardClick = useCallback(
    (x, y) => {
      if (board[x][y] || winner || isAiTurn) return;
      const newBoard = board.map(row => row.slice());
      newBoard[x][y] = playerColor;
      setBoard(newBoard);

      if (checkWin(x, y, playerColor, newBoard)) {
        setWinner(playerColor);
        alert('玩家获胜！');
        return;
      }

      setIsAiTurn(true);
    },
    [board, winner, isAiTurn, playerColor]
  );

  // AI 落子逻辑
  useEffect(() => {
    if (isAiTurn && !winner) {
      setTimeout(() => {
        const [bestX, bestY] = getBestMove(board.map(row => row.slice()), aiColor, playerColor);
        handleBoardClickForAi(bestX, bestY);
      }, 500);
    }
  }, [isAiTurn, board, winner]);

  // AI 落子
  const handleBoardClickForAi = (x, y) => {
    if (board[x][y] || winner) return;
    const newBoard = board.map(row => row.slice());
    newBoard[x][y] = aiColor;
    setBoard(newBoard);

    if (checkWin(x, y, aiColor, newBoard)) {
      setWinner(aiColor);
      alert('AI获胜！');
      return;
    }

    setIsAiTurn(false);
  };

  // 渲染棋盘
  return (
    <div className="game-board">
      <h1>五子棋</h1>
      {winner && <h2>{winner === playerColor ? '玩家获胜！' : 'AI获胜！'}</h2>}
      <div className="board">
        {board.map((row, rowIndex) => (
          <div className="row" key={rowIndex}>
            {row.map((cell, cellIndex) => (
              <div
                key={cellIndex}
                className={`cell ${
                  cell === BLACK ? 'black' : cell === WHITE ? 'white' : ''
                }`}
                onClick={() => handleBoardClick(rowIndex, cellIndex)}
              />
            ))}
          </div>
        ))}
      </div>
    </div>
  );
};

export default App;
